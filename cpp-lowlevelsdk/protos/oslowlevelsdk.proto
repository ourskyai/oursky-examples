syntax = "proto3";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

package oslowlevelsdk;

// Service defining low-level access to the system's axes status.
service OSLowLevelSdkService {
  // Server streaming RPC that continuously streams the status of multiple axes.
  // The client sends a request specifying the desired update interval and whether
  // detailed axis status should be included. The server streams status updates.
  rpc StreamAxesStatus (AxesStatusRequest) returns (stream AxesStatus);
  rpc ApplyMountOffsets(MountOffsetRequest) returns (Status);
}

// Request message for streaming axes status updates.
message AxesStatusRequest {
  // The minimum interval (in microseconds) between two messages.
  // If set to 0, messages will be produced as fast as the cyclic loop is executed;
  // typically 1000 hz, although this may vary depending on attached hardware
  int32 minimum_interval_microseconds = 1;

  // Whether to include detailed status information for each axis.
  bool include_detailed_axis_status = 2;
}

message MountOffsetRequest {
  // If true, the supplied offset values will be added to existing offsets. 
  // If false, total offsets will be set to the specified values.
  bool is_relative = 1;

  // The offset to be applied to either or both axes.
  // For any axis without a value, the existing offset for that axis will
  // remain unchanged.
  optional double mount_axis0_offset_radians = 2;

  optional double mount_axis1_offset_radians = 3;
}

// The `Status` type defines a logical error model that is suitable for
// different programming environments, including REST APIs and RPC APIs. It is
// used by [gRPC](https://github.com/grpc). Each `Status` message contains
// three pieces of data: error code, error message, and error details.
//
// You can find out more about this error model and how to work with it in the
// [API Design Guide](https://cloud.google.com/apis/design/errors).
message Status {
  // The status code, which should be an enum value of
  // [google.rpc.Code][google.rpc.Code].
  int32 code = 1;

  // A developer-facing error message, which should be in English. Any
  // user-facing error message should be localized and sent in the
  // [google.rpc.Status.details][google.rpc.Status.details] field, or localized
  // by the client.
  string message = 2;
  // A list of messages that carry the error details.  There is a common set of
  // message types for APIs to use.
  repeated google.protobuf.Any details = 3;
}

// Detailed status of an individual axis.
message DetailedAxisStatus {
  // The actual encoder position, in counts.
  int32 position_actual_counts = 1;

  // Target position of the servo loop in the drive, in encoder counts. 
  // This value is generated by the motion profiler based on any active motion commands.
  // For example, if the axis is at position 0 and a goto is commanded to position 100,000, this value will 
  // equal various intermediate values from 0 to 100,000 during the movement based on the 
  // acceleration, deceleration, and maximum velocity settings used for the movement.
  int32 position_demand_counts = 2;

  // The difference between the sampled encoder position and the demanded encoder position 
  // during the current iteration of the servo loop. This value is fed back into the control loop, 
  // and the system is always trying to drive this value to 0. Large values can indicate that the axis 
  // is poorly tuned, the axis is being pushed/held out of place by an external disturbance or obstruction, 
  // or the motor is incapable of moving the load at the commanded acceleration/velocity.
  int32 position_following_error_counts = 3;

  // The measured axis velocity during the last iteration of the servo loop, in encoder counts per second.
  int32 velocity_actual_counts_per_second = 4;

  // The current desired velocity of the axis, in encoder counts per second, based on the motion 
  // profile generated for the commanded move. If the current velocity is 0 and a large move is 
  // commanded, the demanded velocity will rise (based on acceleration), potentially up to the 
  // maximum commanded velocity, and then will fall to 0 (based on deceleration) as the axis 
  // arrives at the final destination.
  int32 velocity_demand_counts_per_second = 5;

  // The current being drawn by the motor, in amps.
  float motor_current_amps = 6;

  // The currently-applied target offset, in radians.
  double target_offset_radians = 7;
}

// Status message containing information about multiple axes.
message AxesStatus {
  // The timestamp when the status was recorded
  google.protobuf.Timestamp timestamp = 1;

  // The raw angle of the mount’s primary (Azimuth/RA) axis, in radians.
  double encoder_mount_axis0_radians = 2;

  // The raw angle of the mount’s secondary (Altitude/Dec) axis, in radians.
  double encoder_mount_axis1_radians = 3;

  // The computed apparent azimuth angle in radians, transformed from the encoder
  // position using the currently-loaded pointing model.
  double apparent_mount_azimuth_radians = 4;

  // The computed apparent altitude angle in radians, transformed from the encoder
  // position using the currently-loaded pointing model.
  double apparent_mount_altitude_radians = 5;

  // The computed J2000 right ascension, in radians.
  // Transformed from the encoder position using the currently-loaded pointing model and
  // the current timestamp.
  double right_ascension_j2000_radians = 6;

  // The computed J2000 declination, in radians.
  // Transformed from the encoder position using the currently-loaded pointing model and
  // the current timestamp.
  double declination_j2000_radians = 7;

  // (Optional) Detailed status for the mount's primary (Azimuth/RA) axis.
  optional DetailedAxisStatus mountAxis0 = 8;

  // (Optional) Detailed status for the mount's secondary (Altitude/Dec) axis.
  optional DetailedAxisStatus mountAxis1 = 9;
}
